# Fitting

## Linear fitting with `lm()`

```{r include=FALSE, warning = FALSE, message=FALSE, cache=FALSE}
rm(list = ls())
library(ggplot2)
library(patchwork)
library(tidyverse)
theme_set(theme_bw())
```

Let's learn how to do simple linear fits with R's `lm()`{.R} and plot the results.

```{r include=FALSE}
par(cex.lab=1.3, cex.axis=1.3, mgp = c(2.4, .5, 0),
    tck=0.02, mar=c(4, 4, .5, .5), lwd=2, las=1)
```

```{r, warnings=FALSE}
# Create some fake data
d <- tibble(x = 1:10,
            y = x + 1.5*runif(10))
# Fit with a linear model
fit <- lm(y~x, data=d)
# Summary of the fit
summary(fit)
attributes(fit)
# Retrieve the coefficients and errors
coef(fit); coef(fit)[1]; coef(fit)['(Intercept)']
summary(fit)$coefficients; summary(fit)$coefficients["x","Std. Error"]
# Plotting the points and the fit
to_print <- paste("y = ", round(coef(fit)[1],2)," + x*",
                    round(coef(fit)[2],2), sep="")
plot(d, pch=16,main=to_print)
abline(coef(fit), col="red")
library(ggplot2)
theme_set(theme_bw())
ggplot(data=d, aes(x,y)) + 
    geom_point(cex=3) +
    geom_smooth(method="lm") +
    ggtitle(to_print)
```

The function `geom_smooth()`{.R} will fit the data and display the fitted line, but to retrieve the actual coefficients you still need to run `lm()`{.R}.


## Nonlinear Least Squares fitting

### The `nls()` workhorse

You can fit data with your own functions and constraints using [`nls()`{.R}](https://www.rdocumentation.org/packages/stats/versions/3.6.2/topics/nls). Example:


```{r, warnings=FALSE}
# Create fake data
x  <- seq(-5,7,.1)
y  <- dnorm(x, sd = .5) + dnorm(x, mean=2, sd = 1) + runif(length(x))/10 - 0.05
df <- tibble(x=x, y=y)
ggplot(data=df, aes(x,y))+
    geom_point()+
    ggtitle("Some fake data we want to fit with 2 Gaussians")
# Create a function to fit the data
myfunc <- function(x, y0, x0, A, B) {
    y0 + dnorm(x, sd=A) + dnorm(x, mean=x0, sd=B)
}
# Fit the data using a user function
fit_nls <- nls(data=df,
               y ~ myfunc(x, y0, x0, A, B),
               start=list(y0=0, x0=1.5, A=.2, B=.2) # provide starting point
               )
summary(fit_nls)
coef(fit_nls)
# Plotting the resulting function in red
plot(x, y, pch=16)
lines(x, predict(fit_nls), col="red", lwd=2)
```

Or with `ggplot2`{.R}:

```{r, fig.asp=1.2, message=FALSE, warnings=FALSE}
P1 <- ggplot(data=df, aes(x,y))+
    ggtitle("Retrieving the fit performed beforehand")+
    geom_point(size=2, alpha=.5) +
    geom_line(aes(y=predict(fit_nls)), color="red", size=1)
P2 <- ggplot(data=df, aes(x,y))+
    ggtitle("Doing the fit directly withing ggplot2")+
    geom_point(size=2, alpha=.5) +
    geom_smooth(method = "nls", 
                method.args = list(formula = y ~ myfunc(x, y0, x0, A, B),
                                   start=list(y0=0, x0=1.5, A=.2, B=.2)
                                   ), 
                data = df,
                se = FALSE,
                color="red")
P1/P2
```

### Using constraints

In `nls()`{.R} it is even possible to constraint the fitting by adding lower and upper boundaries. These boundaries are useful when you want to give some physical meaning to your parameters, for example, like forcing the width and amplitude to be positive or above a certain minimum value. However, you have to be careful with these and not provide stupid ones, *e.g.*:

```{r, warnings=FALSE}
# Constraining the upper and lower values of the fitting parameters
fit_constr <- nls(data = df,
                  y ~ myfunc(x, y0, x0, A, B),
                  start = list(y0=0, x0=5, A=.2, B=.2),
                  upper = list(y0=Inf, x0=Inf, A=.4, B=1),
                  lower = list(y0=-Inf, x0=4, A=-Inf, B=-Inf),
                  algorithm = "port"
                  )
# Plotting the resulting function in blue
ggplot(data=df, aes(x,y))+
    ggtitle("Beware of bad constraints!")+
    geom_point(size=2, alpha=.5) +
    geom_line(aes(y = predict(fit_constr)), color="royalblue", size=1)
```


### A more robust version of `nls`

Sometimes, `nls()`{.R} will struggle to converge towards a solution, especially if you provide initial guesses that are too far from the expected values.

```{r warning=FALSE, message=FALSE, error=TRUE}
fit3 <- nls(data = df,
            y ~ myfunc(x, y0, x0, A, B),
            start = list(y0=0, x0=5, A=1, B=1)
            )
```

In that case, you may want to use a more robust `nls()`{.R} function such as `nlsLM()`{.R} from the `minpack.lm`{.R} package.

```{r warning=FALSE, message=FALSE}
library(minpack.lm)
fit_nlsLM <- nlsLM(data = df,
                   y ~ myfunc(x, y0, x0, A, B),
                   start = list(y0=0, x0=5, A=1, B=1)
                   )
summary(fit_nls);
summary(fit_nlsLM);
```

Also, `nlsLM()`{.R} won't fail when the fit is exact, whereas `nls()`{.R} will:
```{r warning=FALSE, message=FALSE, error=TRUE}
testdf <- tibble(x = seq(-10,10),
                 y = dnorm(x))
nls(data = testdf,
    y ~ A*dnorm(x, sd=B, mean=x0) + y0,
    start = list(y0=0, x0=0, A=1, B=1)
    )
nlsLM(data = testdf,
    y ~ A*dnorm(x, sd=B, mean=x0) + y0,
    start = list(y0=0, x0=0, A=1, B=1)
    )
```

## The broom library


Thanks to the [`broom`](https://cran.r-project.org/web/packages/broom/vignettes/broom.html) library, it is easy to retrieve all the fit parameters in a `tibble`{.R}:

```{r include=TRUE, warning = FALSE, message=FALSE, cache=FALSE}
library(broom)
# Get all parameters and their error
tidy(fit_nls)
# Get the fitted curve and residuals next to the original data
augment(fit_nls)
```

It is then easy to make a recursive fit on your data without using a `for loop`{.R}, like so:

```{r include=TRUE, warning = FALSE, message=FALSE, cache=FALSE, error=TRUE}
library(broom)
library(tidyverse)
library(ggplot2)
theme_set(theme_bw())
# Create fake data
a <- seq(-10,10,.1)
centers <- c(-2*pi,pi,pi/6)
widths  <- runif(3, min=0.5, max=1)
amp     <- runif(3, min=2, max=10)
noise   <- .3*runif(length(a))-.15
d <- tibble(x=rep(a,3),
            y=c(amp[1]*dnorm(a,mean=centers[1],sd=widths[1]) + sample(noise),
                amp[2]*dnorm(a,mean=centers[2],sd=widths[2]) + sample(noise),
                amp[3]*dnorm(a,mean=centers[3],sd=widths[3]) + sample(noise)),
            T=rep(1:3, each=length(a))
            )
# Plot the data
d %>% ggplot(aes(x=x, y=y, color=factor(T))) + 
    geom_line()
# Fit all data
d_fitted <- d %>% 
    nest(data = -T) %>%
    mutate(fit = purrr::map(data, ~ nls(data = .,
                                y ~ y0 + A*dnorm(x, mean=x0, sd=FW), 
                                start=list(A  = max(.$y),
                                           y0 = .01, 
                                           x0 = .$x[which.max(.$y)], 
                                           FW = .7)
                                )),
           tidied = purrr::map(fit, tidy),
           augmented = purrr::map(fit, augment)
          )
d_fitted
```

In case you want to provide fit parameters that vary depending on the group you are looking at, use the notation `.$column_name`{.R}, like is done here.

Then you can see the results for all your data at once:

```{r include=TRUE, warning = FALSE, message=FALSE, cache=FALSE, error=TRUE}
# data and fit resulting curve
d_fitted %>% 
  unnest(augmented)
# fit parameters
d_fitted %>% 
  unnest(tidied)
# fit parameters as a wide table
d_fitted %>% 
  unnest(tidied) %>% 
  select(T, term, estimate, std.error) %>% 
  pivot_wider(names_from = term, 
              values_from = c(estimate,std.error))
# plot fit result
d_fitted %>% 
    unnest(augmented) %>% 
    ggplot(aes(x=x, color=factor(T)))+
        geom_point(aes(y=y), alpha=0.5, size=3) + 
        geom_line(aes(y=.fitted))
# plot fit parameters
d_fitted %>% 
  unnest(tidied) %>% 
  ggplot(aes(x=T, y=estimate, color=term))+
    geom_point()+
    geom_errorbar(aes(ymin=estimate-std.error,
                      ymax=estimate+std.error),
                  width=.1)+
    facet_wrap(~term, scales="free_y")+
    theme(legend.position = "none")
```






## Exercises {#exo-fits}

<details>
    <summary>**Exercise 1**</summary>

- Load <a href="Data/exo_fit.txt" download target="_blank">exo_fit.txt</a> in a `data.frame`{.R}.
- Using `lm()`{.R} or `nls()`{.R} fit each column as a function of `x` and display the "experimental" data and the fit on the same graph.
    + Tip: Take a look at the function `dnorm()`{.R} to define a Gaussian


<!-- ```{r}
x <- seq(0,10,.1)
y <- 4*x+6+runif(length(x))*5
z <- 10*dnorm(x, mean=4.1,sd=0.52)+2*runif(length(x)) -.5
w <- x^3.1+200*runif(length(x))/2
u <- -pracma::erf(x/.6-5)+runif(length(x), min=-.1, max=.1) + 1
df <- data.frame(x=x, y=y, z=z, w=w, u=u)
plot(df$x, df$u)
write.table(df, "Data/exo_fit.txt", quote=FALSE, row.names=FALSE)
``` -->


</details>


<details>
    <summary>**Exercise 2: application to real data**</summary>

- Load the Raman spectrum <a href="Data/rubis_01.txt" download target="_blank">rubis_01.txt</a>, normalize it to [0,1] and plot it
- Define the Lorentzian function
- Guess grossly the initial parameters and plot the resulting curve as a blue dashed line
- Fit the data by a sum of 2 Lorentzians using `nls()`{.R}
- Add the result on the plot as a red line
- Add the 2 Lorentzian components as area-filled curves with `alpha=0.2`{.R} and two different colors


<details>
    <summary>Solution</summary>

```{r, warnings=FALSE, error=TRUE}
library(tidyverse)
# Load rubis_1.txt, normalize it to [0,1] and plot it
d <- read_table("Data/rubis_01.txt", col_names=c("w", "Int"))
norm01 <- function(x) {(x-min(x))/(max(x)-min(x))}
d$Int_n <- norm01(d$Int)
P <- d %>%
    ggplot(aes(x=w, y=Int_n))+
        geom_point(alpha=0.5)
P
# Define the Lorentzian function
Lorentzian <- function(x, x0=0, FWHM=1){
    2/(pi*FWHM)/( 1 + ((x-x0)/(FWHM/2))^2 )
}
# Guess grossly the initial parameters and plot the resulting curve as a blue dashed line
P+geom_line(aes(y=.03 + 
                    3*Lorentzian(w, x0=3160, FWHM=10) +
                    7*Lorentzian(w, x0=3210, FWHM=10)),
            col="blue", lty=2)
# Fit the data by a sum of 2 Lorentzians using `nls`
fit <- nls(data=d, Int_n ~ y0 +
                    A1*Lorentzian(w,x1,FWHM1)+
                    A2*Lorentzian(w,x2,FWHM2), 
           start=list(y0=0.03,
                      x1=3160, FWHM1=10, A1=3,
                      x2=3200, FWHM2=10, A2=7)
           )
summary(fit)
# Add the result on the plot as a red line
P + geom_line(aes(y=.03 + 
                    3*Lorentzian(w, x0=3160, FWHM=10) +
                    7*Lorentzian(w, x0=3210, FWHM=10)),
            col="blue", lty=2)+
    geom_line(aes(y=predict(fit)), col="red")
# Add the 2 Lorentzian components as area-filled curves with `alpha=0.2` and two different colors
y0   <- coef(fit)['y0']
lor1 <- coef(fit)['A1']*Lorentzian(d$w,x0=coef(fit)['x1'],FWHM=coef(fit)['FWHM1'])
lor2 <- coef(fit)['A2']*Lorentzian(d$w,x0=coef(fit)['x2'],FWHM=coef(fit)['FWHM2'])
P + geom_line(aes(y=.03 + 
                    3*Lorentzian(w, x0=3160, FWHM=10) +
                    7*Lorentzian(w, x0=3210, FWHM=10)),
            col="blue", lty=2)+
    geom_line(aes(y=predict(fit)), col="red")+
    geom_area(aes(y=lor1), fill="royalblue", alpha=.2)+
    geom_area(aes(y=lor2), fill="orange", alpha=.2)
# Or, more compact:
# dd <- data.frame(d, ytot=lor1+lor2+y0,lor1=lor1+y0, lor2=lor2+y0)
# ggplot(data=dd, aes(x=w))+
#     labs(x="Raman Shift [1/cm]", y="Intensity [arb. units]")+
#     geom_point(aes(y=Int_n), alpha=.5)+
#     geom_line(aes(y=ytot), col="red")+
#     geom_area(aes(y=lor1), fill="royalblue", alpha=.2)+
#     geom_area(aes(y=lor2), fill="orange", alpha=.2)+
#     theme_bw()
```

</details>
</details>






<br>
<br>
<br>
<br>
<br>



