# Practical case: recursive data treatment




Here I will provide an example workflow for treating large amounts of experimental measurements. There are many ways of doing this, this is just a working example. 

You will find <a href="https://github.com/colinbousige/Rclass/raw/master/Data/XPdata.zip" download target="_blank">here</a> the corresponding experimental data.

My way of doing things – again, maybe not the best, but it's what I do – is that for each experiment I create a folder containing at least 4 objects:

- `log.Rmd`: the markdown or R notebook in which I treat the data. I can produce a pdf or html document from it. We will see about that in the next section.
- `myfunc.R`: my user-defined functions that I can load in my working environment using `source(myfunc.R)`
- `Data/`: folder containing the original data (usually ASCII files) that I _never modify_ (reproducible data treatment and all that)
- `Plots/`: folder containing the static (pdf) plots produced with `log.Rmd`

So, let's begin. First we set up our working environment:

```{r, warnings=FALSE, message=FALSE}
# Load the needed libraries
library(ggplot2)
library(tidyverse)
library(plotly)
# and load the user-defined functions
source("myfunc.R")
Lor <- function(x,x0=0,FWHM=1){
    2/(pi*FWHM)/( 1 + ((x-x0)/(FWHM/2))^2 )
}
```

In the working directory, we create a folder `Data` in which we extract the <a href="https://github.com/colinbousige/Rclass/raw/master/Data/XPdata.zip" download target="_blank">XPdata.zip</a> archive. It contains a number of txt files named `rubis_XX.txt`. They are Raman spectra of ruby chips under pressure used for the calibration of pressure in a diamond anvil cell, their shift is directly correlated to the pressure in the DAC.

First, let's list all these files:
```{r, warning=FALSE}
# Find all the files in "Data"
frubis <- list.files(path="Data", pattern = "rubis")
head(frubis)
length(frubis)
# Create a tibble to store each spectra
spec   <- tibble()
# and a tibble to store the fit parameters
fitpar <- tibble()
```

Now let's read the data, store them in the tibble `spec` together with other informations, such as the name of the file, the fitted curves of the peaks, or the obtained pressure (the function `Pruby()` is defined in `myfunc.R`).

```{r, out.width='100%', fig.asp=.85, cache=FALSE, warning=FALSE, message=FALSE}
# Reading and storing all treated data 
for(i in seq_along(frubis)){
    # Reading raw data to a tibble
    d <- read_table2(file.path("Data",frubis[i]), 
                  col_names = c("w", "Int") )
    # Fitting two Lorentzians using the previously defined function Lor()
    # Initial guess of the position and parameters:
    xmax  <- d$w[which.max(d$Int)] 
    Guess <- c(y0   = 0.01,               # constant background
               x    = c(xmax-2, xmax-30), # positions
               FWHM = c(10, 10),          # full width at half maximum
               A    = c(max(d$Int), max(d$Int))*10 # amplitudes
               )
    fit <- nls(data =d, Int ~ y0 + A1*Lor(w,x1,FWHM1) + A2*Lor(w,x2,FWHM2), 
               start=as.list(Guess), 
               lower=as.list(Guess*0),
               algorithm = "port"
           )
    # Compute the various components of the fit
    p  <- coef(fit)
    y0 <- p['y0']
    y1 <- p['A1']*Lor(d$w, x0=p['x1'], FWHM=p['FWHM1'])
    y2 <- p['A2']*Lor(d$w, x0=p['x2'], FWHM=p['FWHM2'])
    ytot <- y0+y1+y2
    # Store all the data and fits in a tidy tibble
    spec <- bind_rows(spec, 
                tibble(w      = d$w,
                       Int    = d$Int, 
                       Int_n  = d$Int/max(d$Int), 
                       y1     = y1,
                       y1_n   = y1/max(d$Int),
                       y2     = y2,
                       y2_n   = y2/max(d$Int),
                       ytot   = ytot,
                       ytot_n = ytot/max(d$Int),
                       name   = gsub(".txt","",frubis[i]),
                       P      = round(Pruby(coef(fit)['x1']),2)
                       )
            )
    # Store the fitting parameters in a tidy data.frame
    fitpar <- bind_rows(fitpar, 
                tibble(param = names(coef(fit)),
                       fit   = coef(fit),
                       name  = gsub(".txt","",frubis[i]),
                       P     = round(Pruby(p['x1']),2)
                       )
              )
    # Uncomment and plot to check if everything is OK:
    # j <- i
    # ggplot(data=subset(spec, name==gsub(".txt","",frubis[j])),aes(x=w)) +
    #   ggtitle(gsub(".txt","",frubis[j]))+
    #   geom_point(aes(w,Int))+
    #   geom_line(aes(w,ytot),color="red")+
    #   geom_area(aes(w,y1),fill="orange", alpha=0.1)+
    #   geom_area(aes(w,y2),fill="royalblue", alpha=0.1)+
    #   theme_bw()
}
```

Now let's take a global look at our data. For this I like the slider functionality of `plotly`. Make your `ggplot` as usual, and just add the keyword `frame` that is read by `ggplotly()`:

```{r, out.width='100%', fig.asp=.85, cache=FALSE, warning=FALSE, message=FALSE}
gg <- ggplot(data=spec,aes(x=w)) +
          labs(x="Raman Shift [1/cm]", y="Intensity [arb. units]")+
          geom_point(aes(x=w, y=Int_n, frame=P))+
          geom_line(aes(x=w,y=ytot_n, frame=P),color="red")+
          geom_line(aes(x=w,y=y1_n, frame=P),color="royalblue", alpha=0.5)+
          geom_line(aes(x=w,y=y2_n, frame=P),color="orange", alpha=0.5)+
          theme_bw()
ggplotly(gg, dynamicTicks = TRUE) %>%
  animation_opts(5)%>%
  layout(xaxis = list(autorange=FALSE, range = c(3050, 3550)))%>%
  animation_slider(
    currentvalue = list(prefix = "Pressure: ", 
                        suffix = " GPa", font = list(color="red"))
  )
```

<br>
In case you want to save all the plots in a pdf file, you'd do something like that:

```r
pdf("Plots/plots_fits.pdf",height=6, width=8)
for(f in frubis){
    p <- ggplot(data=subset(spec, name==gsub(".txt","",f)),aes(x=w)) +
            geom_point(aes(w,Int))+
            labs(x="Raman Shift [1/cm]", y="Intensity [arb. units]")+
            ggtitle(gsub(".txt","",f))+
            geom_line(aes(w,ytot),color="red")+
            geom_area(aes(w,y1),fill="orange", alpha=0.1)+
            geom_area(aes(w,y2),fill="royalblue", alpha=0.1)+
            theme_bw()
    print(p)
}
dev.off()
```

where the line `print(p)` is necessary, since `ggplot` does not output plots when embedded in a for loop.

Now we can also plot the evolution of the fit parameters. Let's only look at the position of the peaks:

```{r, out.width='100%', fig.asp=.85,cache=FALSE, warning=FALSE, message=FALSE}
p <- fitpar %>% filter(grepl('x', param)) %>% 
        ggplot(aes(x=name, y=fit, color=param)) +
            scale_color_manual(values = c('black','red'))+
            geom_point(size=2)+
            theme_bw() +
            theme(axis.text.x = element_text(angle = 45, hjust=1))
ggplotly(p, dynamicTicks = TRUE)
```

And *voilà*! in a few lines of code, you have treated a number of spectra in the same manner, plotted the fits, obtained the fitting parameters and deducted the corresponding pressure.

You are now ready to get to work!

