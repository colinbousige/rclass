---
title : "R Exercises - Spectroscopic data"
date  : "`r Sys.Date()`"
output: 
    html_document:
        toc            : true
        toc_float      : true
        toc_depth      : 4
        highlight      : tango
        number_sections: false
        code_download  : TRUE
params: 
    solution:
        value: true
---



# Exercise 1 - FTIR

- Load the `readxl` and `tidyverse` libraries.
- Load `FTIR_rocks.xlsx` into a `data.frame` (in fact, `tibble`).
- Rename the columns with simpler names, such as "w", "r1", "r2" and "r3"
- Find the wavenumber value of the maximum of each spectrum
- Create a function `norm01()` that, given a vector, returns the vector normalized to [0,1]
- Normalize all columns of FTIR intensity to [0,1]
- Using base graphics or `ggplot2`, as you wish, try to reproduce the following graphs:


<details>
    <summary>__Base R solution__</summary>

```{r warning = FALSE, message=FALSE, cache=FALSE, fig.height=3.3}
# Load the `readxl` and `tidyverse` libraries.
library(readxl)
library(tidyverse)
# Load `FTIR_rocks.xlsx` into a `data.frame` (in fact, `tibble`).
df <- read_excel("Data/FTIR_rocks.xlsx")
# Rename the columns with simpler names, such as "w", "r1", "r2" and "r3"
names(df) <- c("w", "r1", "r2", "r3")
# Find the wavenumber value of the maximum of each spectrum
w_max1 <- df$w[which.max(df$r1)]
w_max2 <- df$w[which.max(df$r2)]
w_max3 <- df$w[which.max(df$r3)]
# Create a function `norm01()` that, given a vector, returns the vector normalized to [0,1]
norm01 <- function(x) {
    (x-min(x))/(max(x)-min(x))
}
# Normalize all columns of FTIR intensity to [0,1]
# we will store it in new columns so that not to lose the initial data
df$r1_norm <- norm01(df$r1)
df$r2_norm <- norm01(df$r2)
df$r3_norm <- norm01(df$r3)
# Plotting the three spectra together
#reduce the top and right margins to make it nicer
par(mar=c(4,4,1,1))
# 1. Plot the first spectrum with lines (default color is black)
# and set the labels text
plot(df$w, df$r1_norm,
    type="l",
    xlab="Wavenumber [1/cm]", 
    ylab="Intensity [arb. units]",
    lwd=2
    )
# add the second spectrum with blue line
lines(df$w, df$r2_norm, col="royalblue", lwd=2)
# add the third spectrum with red line
lines(df$w, df$r3_norm, col="red", lwd=2)
# 2. Plot the 3 spectra stacked and vertically shifted by 1
#reduce the top and right margins
par(mar=c(4,4,1,1))
# first spectrum, not shifted   
plot(df$w, df$r1_norm,
    type="l",
    xlab="Wavenumber [1/cm]", 
    ylab="Intensity [arb. units]",
    ylim=c(0,3),
    lwd=2
    )
# second one, shifted by 1
lines(df$w, df$r2_norm + 1, col="royalblue", lwd=2)
# second one, shifted by 2
lines(df$w, df$r3_norm + 2, col="red", lwd=2)
```
</details>


<details>
    <summary>__Tidyverse+ggplot solution__</summary>

```{r warning = FALSE, message=FALSE, cache=FALSE}
library(readxl)
library(tidyverse)
df <- read_excel("Data/FTIR_rocks.xlsx")
names(df) <- c("w", "r1", "r2", "r3")
norm01 <- function(x) {(x-min(x))/(max(x)-min(x))}
df$r1_norm <- norm01(df$r1)
df$r2_norm <- norm01(df$r2)
df$r3_norm <- norm01(df$r3)
```

A "non-tidyverse-friendly" solution is to make a direct plot, like that:
```{r include=TRUE, warning = FALSE, message=FALSE, cache=FALSE, fig.height=4}
ggplot(df, aes(x=w))+
        geom_line(aes(y=r1_norm), size=1, col="black")+
        geom_line(aes(y=r2_norm), size=1, col="royalblue")+
        geom_line(aes(y=r3_norm), size=1, col="red")+
        labs(x="Wavenumber [1/cm]", y="Intensity [arb. units]")+
        theme_bw()
ggplot(df, aes(x=w))+
        geom_line(aes(y=r1_norm), size=1, col="black")+
        geom_line(aes(y=r2_norm+1), size=1, col="royalblue")+
        geom_line(aes(y=r3_norm+2), size=1, col="red")+
        labs(x="Wavenumber [1/cm]", y="Intensity [arb. units]")+
        theme_bw()
```

For a "tidyverse-friendly" solution, you need to use a tidy data.frame. For such a simple task, the following may seem more complicated than the direct solution, but for complicated stuff it's a life saver.
You see that `df` is not tidy: each observation should be on a line, each variable on a column.
```{r include=TRUE, warning = FALSE, message=FALSE, cache=FALSE}
df
```
Let's tidy the table by make the "wide" table into a "long" table: for this we use the function `pivot_longer()` from the `tidyverse` library. 

We want to keep the `w` column but modify the others, so: `cols=c(r1_norm, r2_norm, r3_norm)` (no need for quotation marks as `pivot_longer()` looks for column names). A shorter way is to write `cols=-w`, which means "all columns except `w`". 

The column names of the other columns should populate the new column called 'Rock' (`names_to="Rock"`), and the values of the table should populate the new column called 'Intensity', so: `values_to="Intensity"`:

```{r warning = FALSE, message=FALSE, cache=FALSE}
# first, we select only the columns containing "norm" 
# because we will only plot the normalized data
df_tidy <- df[,c("w", "r1_norm", "r2_norm", "r3_norm")]
df_tidy <- pivot_longer(df_tidy, cols=-w, 
                        names_to="Rock", 
                        values_to="Intensity")
df_tidy # is a tidy table
```

Alternatively, a 'tidyverse friendly' way of doing this would be to use the pipe operator, `%>%`, to successively call `df`, select the wanted columns, and then pivot the table to make it tidy:
```{r warning = FALSE, message=FALSE, cache=FALSE}
df_tidy <- df %>%
            select(w, contains("norm")) %>%
            pivot_longer(cols=-w, 
                        names_to="Rock", 
                        values_to="Intensity")
df_tidy
```

Then we want to plot the data using `ggplot2` by specifying that the color should evolve according to the `Rock` column. For this, we add the argument `color=Rock` in the plot aesthetics:
```{r warning = FALSE, message=FALSE, cache=FALSE}
# create a vector containing the wanted colors
colors <- c("black", "royalblue","red")
# set the default theme to theme_bw() to remove the grey background globally
theme_set(theme_bw()) 
ggplot(df_tidy, aes(x=w, y=Intensity, color=Rock))+
        # add the lines with thickness of 1
        geom_line(size=1)+
        # change the axis labels
        labs(x="Wavenumber [1/cm]", y="Intensity [arb. units]")+
        # set the color to the wanted colors and give a name to 
        # the legend if you want to plot the legend
        # if this line is absent, ggplot uses its default colors (blue, red, green)
        scale_color_manual(values=colors, name="Rock: ")+
        # to remove the legend, set it to "none"
        # if you remove this line, the default is to show the legend on the right
        theme(legend.position="top")
```

For the stacked plot, it's the same, but you want to shift the data according to the 'Rock' column. For this, you need to convert the words in the column `Rock` (*i.e.* `r1_norm`, `r2_norm` or `r3_norm`) into values of 0, 1 or 2. This is done by using the combining the functions `factor()` to convert the characters to `levels`, and `as.numeric()`, to convert the levels to numeric values. `levels` are like vectors of all possible values, and the actual values taken. For example:
```{r include=TRUE, warning = FALSE, message=FALSE, cache=FALSE}
x <- c('a', 'b', 'c', 'a', 'b', 'b')
factor(x)
as.numeric(factor(x))
```

So, for the plot:
```{r warning = FALSE, message=FALSE, cache=FALSE}
ggplot(df_tidy, aes(x=w, 
                    y=Intensity+as.numeric(factor(Rock))-1, 
                    color=Rock))+
        geom_line(size=1)+
        labs(x="Wavenumber [1/cm]", y="Intensity [arb. units]")+
        scale_color_manual(values=colors, name="Rock: ")+
        theme(legend.position="none") 
```
</details>




# Exercise 2 - Raman

- Find in the folder "Data" the list of files with the pattern "rubis\_" in their name (check out the `list.files()` function) and store it in `flist`
- What is the length of `flist`?
- Initialize an empty list called `spec` and an empty `data.frame` called `maxpos`
- Using a `for` loop, load each file in `flist` into separate elements of `spec`, and store the position of the maximum of each spectrum in `maxpos`
- Plot the first element of `spec` to see the x range
- Using a `for` loop and base graphics, plot the spectra normalized to [0,1] and stacked on top of each other with a vertical shift of 1
    - Try doing the same with `ggplot2` (expected graph below)
- Plot the evolution of the position of the maximum (expected graph below)

<details>
    <summary>__Base R solution__</summary>

```{r warning = FALSE, message=FALSE, cache=FALSE, fig.height=4.3}
# Find in the folder "Data" the list of files with the pattern "rubis_" in their name 
# (check out the `list.files()` function) and store it in `flist`
flist <- list.files(path = "Data", pattern = "rubis")
# What is the length of `flist`?
length(flist)
# Initialize an empty list called `spec` and an empty `data.frame` called `maxpos`
spec   <- list()
maxpos <- data.frame(file=flist, max=NA)
# Using a `for` loop, load each file in `flist` into separate elements of `spec`, 
# and store the position of the maximum of each spectrum in `maxpos`
for (file in flist){
    df <- read.table(paste0("Data/",file), col.names=c("w","Int"))
    spec[[file]] <- df
    maxpos$max[file==flist] <- df$w[which.max(df$Int)]
}
# Plot the first element of `spec` to see the x range
plot(spec[[1]])
# Using a `for` loop and base graphics, plot the spectra normalized to [0,1] 
# and stacked on top of each other with a vertical shift of 1
par(mar=c(4,4,1,1))
plot(NA,NA, #initialize an empty plot with the correct x and y ranges
    xlim=c(3100,3500),
    ylim=c(0,length(flist)),
    xlab="Raman Shift [1/cm]",
    ylab="Intensity [arb. units]"
    )
i <- 0
for (file in flist){# iteratively plot lines shifted by 1
    w   <- spec[[file]]$w
    Int <- norm01(spec[[file]]$Int)
    lines(w, Int + i)
    i <- i+1
}
# Plot the evolution of the position of the maximum
par(mar=c(6,4,1,1))
plot(maxpos$max, xlab="", axes=FALSE) 
axis(1, at=seq_along(maxpos$file), labels=maxpos$file, las=2) # las=2 to turn the x label
axis(2)
box()
```
</details>


<details>
    <summary>__Tidyverse+ggplot solution__</summary>

In this case, we will not store the data into a `list` but into a tidy `data.frame`. Thanks to that, we can attribute a color to a given file name, for example.

```{r warning = FALSE, message=FALSE, cache=FALSE, fig.height=3.8}
flist  <- list.files(path = "Data", pattern = "rubis")
spec   <- tibble()
maxpos <- tibble(file=flist, max=NA)
for (file in flist){
    df <- read_table2(paste0("Data/",file), col_names=c("w","Int"))
    spec <- bind_rows(spec, 
                      tibble(w     = df$w,
                             Int   = df$Int,
                             Int_n = norm01(df$Int),
                             name  = file)
                      )
    maxpos$max[file==flist] <- df$w[which.max(df$Int)]
}
head(spec)
# lets define a color vector the size of `flist`
colors <- colorRampPalette(c("royalblue","seagreen","orange","red"))(length(flist))
ggplot(data=spec, aes(x=w,
                      y=Int_n+as.numeric(factor(name))-1,
                      color=name))+# attribute a color based on the `name` column
        geom_line()+
        scale_color_manual(values = colors)+#I want my own colors
        labs(x="Raman Shift [1/cm]", y="Intensity [arb. units]")+
        theme_bw()+
        theme(legend.position="none")
ggplot(data=maxpos, aes(x=file, y=max)) +
    geom_point(size=2)+
    theme_bw()+
    theme(axis.text.x = element_text(angle = 45, hjust=1))
```

</details>

